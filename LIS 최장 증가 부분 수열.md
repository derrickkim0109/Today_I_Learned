<h1><center> LIS 최장 증가 부분 수열 </center></h1>

###### tags: `💻 TIL`
###### date: `2024-03-08T15:12:33.284Z`

> [color=#724cd1][name=데릭]
> [ChanBLOG - LIS](https://chanhuiseok.github.io/posts/algo-49/)
> [나무위키 - LIS](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4)

# 개요 

> DP 문제 중 최장 증가 부분 수열 알고리즘을 만들어야 하는 문제를 접하게 됐는데 개념을 글로 적어볼 필요가 있다.

## LIS 최장 증가 부분 수열

> 어떤 임의의 수열이 주어질 때, 이 수열에서 몇 개의 수들을 제거해서 부분수열을 만들 수 있다. 이때 만들어진 부분수열 중 오름차순으로 정렬된 가장 긴 수열을 **최장 증가 부분 수열**이라 한다.


예를 들어, 다음 수열이 주어졌다고 하자.

[3, 5, 7, 9, 2, 1, 4, 8]

위 수열에서 몇 개의 수를 제거해 부분수열을 만들 수 있다.

3 7 9 1 4 8 (5, 2 제거)
7 9 1 8 (3, 5, 2, 4 제거)
3 5 7 8 (9, 2, 1, 4 제거)
1 4 8 (3, 5, 7, 9, 2 제거)

이들 중 첫번째, 두번째 수열은 **일부**가 오름차순으로 정렬되어 있다.
반면에 세번째, 네번째 수열은 **전체**가 오름차순으로 정렬되어 있다.
위와 같이 **일부** 혹은 **전체**가 오름차순인 수열을 **증가 부분 수열**이라고 한다.

그리고 이런 증가 부분 수열 중 가장 긴 수열을 **최장 증가 부분 수열 (LIS)** 이라 한다.
즉, 위의 수열의 집합에선 부분수열 3 5 7 8이 LIS이다.

한 수열에서 여러 개의 LIS가 나올 수도 있다. 예를 들어 수열 [5, 1, 6, 2, 7, 3, 8]에서 부분수열

1 2 3 8
5 6 7 8

은 모두 길이가 4인 LIS이다.

## 첫 번째 알고리즘: $O(N^2)$

새로운 배열 dp를 정의하자. 

dp[i]: A[i]를 마지막 값으로 가지는 가장 긴 증가부분 수열의 길이.

A[i]가 어떤 증가부분수열의 마지막 값이 되기 위해서는 A[i]가 추가되기 전 증가부분수열의 마지막 값이 A[i]보다 작은 값이여야 한다.

**따라서, A[i]를 마지막 값으로 가지는 가장 긴 증가부분수열의 길이는 A[i]가 추가될 수 있는 증가부분수열 중 가장 긴 수열의 길이에 1을 더한 값이 된다.** 

수열 A = [3, 5, 7, 9, 2, 1, 4, 8]

* i = 0 
![스크린샷 2024-03-08 09.35.11](https://hackmd.io/_uploads/HJqHaRDTp.png)

* i = 1
![스크린샷 2024-03-08 09.35.42](https://hackmd.io/_uploads/rkdvTCwT6.png)
A[1] = 3이다. 3은 A[0] = 0 뒤에 붙을 수 있다. 따라서 dp[1] = dp[0] + 1= 1이다.

* i = 2
![스크린샷 2024-03-08 09.38.05](https://hackmd.io/_uploads/BywxCAvpT.png)
A[2] = 5이다. A[0] = 0, A[1] = 3 뒤에 붙을 수 있다. 이때 dp[0] = 0, dp[1] = 1에서 dp[1]이 가장 크다. 이 말은 A[1] = 3을 가장 마지막 값으로 가지는 증가부분수열의 길이가 가장 길다는 뜻이다. A[2]가 가장 긴 증가부분수열 뒤에 붙는 게 더 긴 증가부분수열을 만들 수 있다. 
따라서, dp[2] = dp[1] + 1 = 2이다.

* i = 3
![스크린샷 2024-03-08 09.37.45](https://hackmd.io/_uploads/ByPJ0Cwpa.png)
A[3] = 7이다. 7는 A[0] = 0, A[1] = 3, A[2] = 5 뒤에 붙을 수 있다. 이 때 D[0] = 0, dp[1] = 1, dp[2] = 2에서 dp[2]가 가장 크다. 따라서 dp[3] = dp[2] + 1 = 3이다.

* i = 4
![스크린샷 2024-03-08 09.38.14](https://hackmd.io/_uploads/rkzbCRv6T.png)
A[4] = 9이다. 9는 A[0] = 0, A[1] = 3, A[2] = 5, A[3] = 7 뒤에 붙을 수 있다. 이 때 dp[0] = 0, dp[1] = 1, dp[2] = 2, dp[3] = 3에서 dp[3]이 가장 크다. 따라서 dp[4] = dp[3] + 1 = 4이다.

* i = 5
![스크린샷 2024-03-08 09.38.24](https://hackmd.io/_uploads/rkqZ0AP6T.png)
A[5] = 2이다. 2는 A[0] = 0 뒤에 붙을 수 있다. 따라서 dp[5] = dp[0] + 1 = 1이다.

* i = 6
![스크린샷 2024-03-08 09.38.32](https://hackmd.io/_uploads/S17MRCw66.png)
A[6] = 1이다. 2는 A[0] = 0 뒤에 붙을 수 있다. 따라서 dp[6] = dp[0] + 1 = 1이다.

* i = 7
![스크린샷 2024-03-08 09.38.42](https://hackmd.io/_uploads/H1afRAwT6.png)

A[7] = 4이다. 4는 A[0] = 0, A[1] = 3, A[5] = 2, A[6] = 1 뒤에 붙을 수 있다. 이 때 dp[0] = 0, dp[1] = 1, dp[5] = 1, dp[6] = 1에서 D[1] = dp[5] = dp[6] = 1이 가장 크다. 따라서 dp[4] = dp[1] + 1 = 2이다.


* i = 8
![스크린샷 2024-03-08 09.38.50](https://hackmd.io/_uploads/BJBX00D66.png)

A[8] = 8이다. 8는 A[0] = 0, A[1] = 3, A[2] = 5, A[3] = 7, A[5] = 2, A[6] = 1, A[7] = 4 뒤에 붙을 수 있다. 이 때 D[0] = 0, dp[1] = 1, dp[2] = 2, dp[3] = 3, dp[5] = 1, dp[6] = 1, dp[7] = 2에서 dp[3] = 3이 가장 크다. 따라서 dp[4] = dp[3] + 1 = 4이다

```swift 
let n = 8
var array = [3, 5, 7, 9, 2, 1, 4, 8]
var dp = Array(repeating: 0, count: n + 1)

for i in 0..<n {
    dp[i + 1] = 1

    for j in 0..<i+1 {
        if array[i] > array[j] {
            dp[i + 1] = max(dp[i + 1], dp[j + 1] + 1)
        }
    }
}
```

주어진 배열에서 인덱스를 한 칸씩(i += 1)늘려가면서 확인한다. 그리고 내부 반복문으로 i보다 작은 인덱스들을 하나씩 살펴 보면서 array[i] > array[j]를 만족할 경우, dp[i + 1]의 값을 업데이트 한다. 

**업데이트 기준**
> j 번째 인덱스에서 끝나는 최장 증가부분수열의 마지막에 array[i]를 추가했을 때의 LIS길이와 추가하지 않고 기존의 dp[i+1] 값 중 더 큰 값으로 dp[i+1] 값을 업데이트한다.

## 두 번째 알고리즘: 이분탐색 $O(NlogN)$

LIS의 형태를 유지하기 위해 주어진 배열의 인덱스를 하나씩 살펴보면서 그 숫자가 들어갈 위치를 이분탐색으로 탐색해서 넣으면 된다.

![image](https://hackmd.io/_uploads/S1_KzyOT6.png)

```swift 
let n = Int(readLine()!)!
var arr = readLine()!.split(separator: " ").map { Int(String($0))! }
var lis = Array(repeating: 0, count: 1001)
var j = 0
var i = 1

lis[0] = arr[0] // lis 배열의 맨 첫번째 값은 arr[0]으로 초기화

// arr의 두번째부터 마지막까지 하나씩 lis와 비교하면서 넣어준다.
while i < n {
    // lis 배열의 맨 뒤의 값보다 arr[i]가 더 크면 그것을 lis 배열 맨 뒤에 넣어준다.
    if lis[j] < arr[i] {
        lis[j + 1] = arr[i]
        j += 1
    } else {
        // arr[i]값이 더 작으면, arr[i]의 값이 lis 배열 중 어느 곳에 들어올지 이분탐색한다.
        
        // 0부터 j까지 탐색하면서 arr[i]가 들어갈 수 있는 위치를 찾아서 idx에 반환
        let idx = binarySearch(0, j, arr[i])
        lis[idx] = arr[i]
    }
    
    i += 1
}

print(j + 1)

func binarySearch(_ left: Int, right: Int, _ target: Int) -> Int {
    var left = left 
    var right = right
    var mid = 0 
    
    while left < right {
        mid = (left + right) / 2
        
        if lis[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return right
}

```