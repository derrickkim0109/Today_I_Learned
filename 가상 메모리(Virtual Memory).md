<h1><center> 가상 메모리 </center></h1>

###### tags: `💻 TIL`
###### date: `2024-02-05T15:12:33.284Z`

> [color=#724cd1][name=데릭]
> [Nossi.DEV](https://www.nossi.dev/319f2e64-863e-4792-b31f-b7a030a26a02)

> [혼공운](https://www.notion.so/derrickkim/14-02-6b6998aa427c4d069b1a653c424c526a?pvs=4)

> [가상 메모리 위키백과](https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC)

> [Nossi.DEV](https://www.nossi.dev/319f2e64-863e-4792-b31f-b7a030a26a02)

## 가상 메모리(Virtual Memory)

> 가상 메모리에 대해 설명하기 전에 프로세스를 메모리에 연속적으로 할당하는 방식에서의 문제에 대해 알아야 한다. 연속적으로 할당하게 되면 두 가지 문제를 내포하고 있다. <br>

1. 외부 단편화
2. 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점

![image](https://hackmd.io/_uploads/SyQnNha56.png)

프로세스를 반드시 메모리에 연속적으로 할당해야 한다면 메모리보다 큰 프로그램은 적재할 수 없다. 

가상 메모리는 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다. 가상 메모리 관리 기법으로 크게 페이징과 세그멘테이션이 있다. 

즉, 프로세스는 운영체제로부터 할당받은 자신만의 가상 메모리를 가진다. 이를 통해 Code, Data, Stack, Heap을 관리한다. 

다시 말해, 가상 메모리는 실제 물리 메모리 개념과 개발자 입장의 논리 메모리 개념을 분리한 것이다.

운영체제는 가상 메모리 기법을 통해 프로그램의 논리적 주소 영역에서 필요한 부분만 물리 메모리에 적재하고, 직접적으로 필요하지 않은 메모리 공간은 디스크(Swap 영역)에 저장하게 된다. 

### 요구 페이징(Demand Paging)

> 프로세스를 메모리에 적재할 때 당장 사용될 주소공간을 page 단위로 메모리에 적재하는 방법

**요구 페이징의 기본적인 양상**

> 특정 페이지에 대해 CPU의 요청이 들어온 후, 해당 페이지를 메모리에 적재한다. 당장 실행에 필요한 페이지만 메모리에 적재하기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 적재하는 입출력 오버헤드도 감소하는 장점이 있다. 요구 페이징 기법에서는 `유효/무효(valid / invalid bit)`를 두어 각 페이지가 메모리에 존재하는지 표시하게 된다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행한다
2. 해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우 (유효 비트가 0일 경우) 페이지 폴트가 발생한다
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 수행한다.

참고로 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있습니다. 이 경우 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어집니다.

이를 `**순수 요구 페이징(pure demand paging)**` 기법이라고 합니다.

요구 페이징 시스템이 안정적으로 작동하려면 필연적으로 다음 두 가지를 해결해야 합니다. 

하나는 `페이지 교체`이고, 다른 하나는 `프레임 할당`입니다.

**Page Fault**

> CPU가 무효 비트(invalid bit)로 표시된 페이지에 접근하는 상황을 말한다. CPU가 무효 페이지에 접근하면 주소 변환을 담당하는 하드웨어인 MMU가 Page Fault Trap을 발생시키게 되고, 다음과 같은 순서로 Page Fault를 처리하게 된다.

![image](https://hackmd.io/_uploads/rks582aq6.png)

1. CPU가 페이지 N을 참조
2. Page Table에서 페이지 N이 무효 상태임을 확인
3. MMU에서 Page Fault Trap이 발생
4. 디스크에서 페이지 N을 빈 프레임에 적재하고 Page Table을 업데이트(Invalid -> Valid)

**NOTE**

> Page Table: 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU는 이를 순차적으로 실행할 수 없다. 왜냐면, 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 모두 알고 있기 어렵기 때문이다. 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU입장에서 다음에 실행할 명령어를 찾기 어려워진다. 이를 해결하기 위해 페이징 시스템은 프로세스가 비록(실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용한다. 페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표다.

**Page 교체 알고리즘(Replacement Algorithm)**

Page Falut가 발생하면, 요청된 페이지를 디스크에서 메모리로 가져온다. 이 때, 물리적 메모리에 공간이 부족할 수 있다. 그럴 경우, 메모리에 올라와 있는 페이지를 디스크로 옮겨 메모리 공간을 확보해야 한다. 이를 페이지 교체라고 하고, 어떤 페이지를 교체할 것인지 결정하는 알고리즘을 페이지 교체 알고리즘이라 한다.

교체 알고리즘은 최대한 Page Fault가 적게 일어나도록 도와줘야 한다. 따라서, 앞으로 참조될 가능성이 적은 페이지를 선택해 교체하는 것이 성능을 향상시키는 방법이다.

![스크린샷 2024-02-05 10.20.59](https://hackmd.io/_uploads/B1rW_hp9T.png)
