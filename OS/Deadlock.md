<h1><center> 교착상태(Deadlock) </center></h1>

###### tags: `💻 TIL`, `Computer Science`, `Operation System`
###### date: `2024-02-02T15:12:33.284Z`

> [color=#724cd1][name=데릭]
> [교착상태](hhttps://www.nossi.dev/d42a6f0e-492a-4a23-ab97-fb30e78f054c)
> [혼공운 - 내 노션](https://www.notion.so/derrickkim/13-01-a57d00fce32a4f9e85d3c8b39bd9a711?pvs=4)
> [Nossi.DEV](https://www.nossi.dev/d42a6f0e-492a-4a23-ab97-fb30e78f054c)

## 교착상태

둘 이상의 Thread가 각기 다른 Thread가 점유하고 있는 자원을 서로 기다릴 때, 무한 대기에 빠지는 상황을 말한다. 

## 교착 상태 발생 조건

발생 조건은 총 4가지 있다.

- 상호배제
- 점유와 대기
- 비선점
- 원형 대기

**4가지 중 하나라도 만족하지 않는다면 교착 상태가 발생하지 않지만**, 모두 만족될 때 교착 상태가 발생할 가능성이 생긴다고 보면 된다.

Deadlock 문제를 해결하는 방법에는 무시, 예방, 회피, 탐지-회복 4가지 방법이 있다.

![image](https://hackmd.io/_uploads/HJaJ1M5ca.png)

> Deadlock 예시

### 상호 배제 

우선 교착 상태가 발생한 근본적인 원인은 해당 자원을 한 번에 하나의 프로세스만 이용했기 때문이다. 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때, 상호 배제 상황에서 교착 상태가 발생할 수 있다. 

- 동시에 한 Thread만 자원을 점유할 수 있는 상황.
- 다른 Thread가 자원을 사용하려면 자원이 방출될 때까지 기다려야 함.

### 점유와 대기

어떠한 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있다. 이렇게 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태를 점유와 대기(Hold and Wait)라고 한다. 

- Thread가 자원을 보유한 상태에서 다른 Thread가 보유한 자원을 추가로 기다리는 상황.

### 비선점

비선점 자원은 그 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용할 수 있다. 즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 교착 상태가 발생했다고 볼 수 있다. 

- 다른 Thread가 사용 중인 자원을 강제로 선점할 수 없는 상황.
- 자원을 점유하고 있는 Thread에 의해서만 자원이 방출된다.

### 원형 대기

교착상태가 발생하는 마지막 이유는 여러 프로세스들이 요청하고 할당받은 자원이 원형으로 연결된 구조를 형성했기 때문이다. 다시 말해, 자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 수 있다. 이렇게 프로세스들이 원의 형태로 자원을 대기하는 것을 원형 대기(Circular Wait)라고 한다.

- 대기 중인 Thread들이 순환 형태로 자원을 대기하고 있는 상황

### 교착 상태 해결 방법

**무시**

> Deadlock 발생 확률이 낮은 시스템에서 아무런 조치도 취하지 않고 Deadlock을 무시하는 방법

- 무시 기법은 시스템 성능 저하가 없다는 큰 장점이 있다. 
- 현대 시스템에서는 Deadlock이 잘 발생하지 않고, **해결 비용이 크기 때문에** 무시 방법이 많이 사용됨

**예방**

> 교착 상태의 4가지 발생 조건중 하나가 성립하지 않게 하는 방법

- 순환 대기 조건이 성립하지 않도록 하는 것이 현실적으로 가능한 예방 기법이다. 
- **자원 사용의 효율성이 떨어지고 비용이 크다.**

**회피**

> Thread가 앞으로 자원을 어떻게 요청할지에 대한 정보를 통해 순환 대기 상태가 발생하지 않도록 자원을 할당하는 방법

- 자원 할당 그래프 알고리즘, 은행원 알고리즘 등을 사용하여 자원을 할당하여 deadlock을 회피한다.

**탐지-회복**

시스템 검사를 통해 deadlock발생을 탐지하고, 이를 회복시키는 방법

- **자원 사용의 효율성이 떨어지고 비용이 크다.**

